<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kutucuk İttirme Oyunu</title>
    
    <style>
        /* Genel body stil ayarları */
        body {
            margin: 0;
            overflow: hidden; /* Sayfanın kaydırılmasını engeller */
            font-family: 'Inter', sans-serif; /* Yazı tipi Inter olarak ayarlandı */
            display: flex; /* İçeriği yerleştirmek için esnek kutu kullan */
            justify-content: center; /* Yatayda ortala */
            align-items: center; /* Dikeyde ortala */
            min-height: 100vh; /* Minimum yüksekliği viewport yüksekliğine ayarlar */
            background-color: #1a202c; /* Koyu gri arka plan rengi */
            color: #e2e8f0; /* Açık gri metin rengi */
        }

        /* Ana sayfa konteyneri stilleri */
        #main-menu {
            display: flex;
            flex-direction: column;
            gap: 20px; /* Butonlar arasında boşluk */
            z-index: 10; /* Canvas'ın üzerinde görünmesini sağlar */
        }

        /* Buton stilleri */
        .menu-button {
            padding: 15px 30px;
            font-size: 1.5em;
            color: #e2e8f0;
            background-color: #4a5568; /* Orta gri arka plan */
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
        }

        .menu-button:hover {
            background-color: #6a768e; /* Hover durumunda biraz daha açık */
            transform: translateY(-2px);
        }

        .menu-button:active {
            background-color: #3a4352; /* Tıklanma durumunda daha koyu */
            transform: translateY(0);
        }

        /* Oyun ekranı aktif olduğunda ana menüyü gizle */
        body.game-active #main-menu {
            display: none;
        }

        /* Canvas stil ayarları - Tam ekran olacak şekilde güncellendi */
        canvas {
            background-color: #2d3748; /* Canvas için daha koyu gri arka plan rengi */
            display: none; /* Başlangıçta gizli */
            touch-action: none; /* Dokunmatik cihazlarda varsayılan kaydırma/yakınlaştırma gibi hareketleri devre dışı bırakır */
            width: 100vw; /* Viewport genişliğinin tamamını kapla */
            height: 100vh; /* Viewport yüksekliğinin tamamını kapla */
            position: fixed; /* Ekranı sabit bir şekilde kapla */
            top: 0;
            left: 0;
            border-radius: 0; /* Tam ekran olduğu için köşeleri yuvarlamaya gerek yok */
            box-shadow: none; /* Tam ekran olduğu için gölgeye gerek yok */
        }

        /* Oyun aktifken canvas'ı göster */
        body.game-active canvas {
            display: block;
        }

        /* Joystick konteyneri */
        #joystick-container {
            position: absolute; /* Canvas'ın üzerinde konumlandırır */
            /* Konumlandırma ve boyutlandırma JS tarafından yapılacak */
            border-radius: 50%; /* Dairesel şekil */
            background-color: rgba(0, 0, 0, 0.3); /* Yarı şeffaf siyah arka plan */
            display: none; /* Başlangıçta gizli */
            justify-content: center;
            align-items: center;
            user-select: none; /* Metin seçmeyi engeller */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            touch-action: none; /* Dokunmatik cihazlarda varsayılan kaydırma/yakınlaştırma gibi hareketleri devre dışı bırakır */
            transition: left 0.1s ease-out, top 0.1s ease-out; /* Konum değişimi için yumuşak geçiş */
        }

        /* Oyun aktifken joystick'i göster */
        body.game-active #joystick-container {
            display: flex;
        }

        #joystick-thumb {
            /* width ve height JS tarafından ayarlanacak */
            border-radius: 50%; /* Dairesel şekil */
            background-color: rgba(255, 255, 255, 0.5); /* Yarı şeffaf beyaz top */
            position: absolute; /* Konteyner içinde mutlak konumlandırma */
            top: 50%; /* Topun dikeyde merkeze hizalanması */
            left: 50%; /* Topun yatayda merkeze hizalanması */
            transform: translate(-50%, -50%); /* Kendi boyutuna göre merkeze hizala */
            touch-action: none; /* Dokunmatik cihazlarda varsayılan kaydırma/yakınlaştırma gibi hareketleri devre dışı bırakır */
        }

        /* Bölüm tamamlandı mesajı */
        #winMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: #e2e8f0;
            padding: 30px 50px;
            border-radius: 15px;
            font-size: 3em;
            font-weight: bold;
            text-align: center;
            z-index: 20; /* Her şeyin üzerinde görünmesini sağlar */
            display: none; /* Başlangıçta gizli */
            cursor: pointer; /* Tıklanabilir olduğunu belirt */
            transition: background-color 0.3s ease;
        }

        #winMessage:hover {
            background-color: rgba(0, 0, 0, 0.9);
        }

        /* Level göstergesi */
        #levelIndicator {
            position: fixed;
            top: 20px;
            left: 20px;
            font-size: 1.5em;
            color: #e2e8f0;
            z-index: 15;
            display: none; /* Başlangıçta gizli */
        }

        /* Timer göstergesi */
        #timerDisplay {
            position: fixed;
            top: 20px;
            right: 20px;
            font-size: 1.5em;
            color: #e2e8f0;
            z-index: 15;
            display: none; /* Başlangıçta gizli */
        }

        body.game-active #levelIndicator,
        body.game-active #timerDisplay {
            display: block;
        }
    </style>
</head>
<body>
    <div id="main-menu">
        <button class="menu-button" id="startButton">Başlat</button>
        <button class="menu-button" id="historyButton">Geçmiş</button>
        <button class="menu-button" id="settingsButton">Ayarlar</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="joystick-container">
        <div id="joystick-thumb"></div>
    </div>

    <div id="winMessage">
        Bölümü Geçtiniz!<br>Devam Etmek İçin Tıklayın
    </div>

    <div id="levelIndicator">
        Level: 1
    </div>

    <div id="timerDisplay">
        Time: 120
    </div>

    <script>
        // Oyun değişkenleri tanımlamaları
        let canvas; // HTML Canvas elementi
        let ctx; // Canvas 2D çizim bağlamı

        let player; // Oyuncu kutusu nesnesi
        let movableBoxes = []; // Hareket ettirilebilir kutuların tutulduğu dizi
        let targetCircles = []; // Hedef çemberlerin tutulduğu dizi
        let obstacles = []; // Yeni: Engel objelerinin tutulduğu dizi
        const NUM_MOVABLE_BOXES = 4; // Oyundaki hareket ettirilebilir kutu sayısı
        const NUM_TARGET_CIRCLES = 4; // Oyundaki hedef çember sayısı
        let PLAYER_SPEED; // Oyuncunun maksimum hareket hızı (ekran boyutuna göre ayarlanacak)
        let playerSize; // Oyuncu kutusunun boyutu (ekran boyutuna göre ayarlanacak)
        let boxSize; // Diğer kutuların boyutu (ekran boyutuna göre ayarlanacak)
        let obstacleSize; // Engel kutularının boyutu (ekran boyutuna göre ayar;lanacak)
        let circleRadius; // Çemberlerin yarıçapı

        let gameRunning = false; // Oyunun devam edip etmediğini tutan değişken
        let currentLevel = 0; // Mevcut oyun seviyesi (0'dan başlar)

        // Joystick değişkenleri
        let joystickContainer; // Joystick konteyner elementi
        let joystickThumb; // Joystick topu elementi
        let joystickHolding = false; // Kullanıcı parmağını/fareyi joystick üzerinde tutuyor mu?
        let joystickThumbX = 0; // Beyaz topun joystick merkezi offset X (global olarak tutulur)
        let joystickThumbY = 0; // Beyaz topun joystick merkezi offset Y (global olarak tutulur)
        let joystickCenterX, joystickCenterY; // Joystick'in merkez koordinatları
        let joystickRadius; // Joystick'in yarıçapı (ekran boyutuna göre ayarlanacak)
        let thumbRadius; // Joystick topunun yarıçapı (ekran boyutunun göre ayarlanacak)

        // Bu yeni değişken, joystick'in dışına tıklanıp tıklanmadığını belirleyecek.
        // true olduğunda sadece joystick yer değiştirir, oyuncu hareket etmez.
        let repositioningJoystick = false; 

        // Ana sayfa elementleri
        const mainMenu = document.getElementById('main-menu');
        const startButton = document.getElementById('startButton');
        const historyButton = document.getElementById('historyButton');
        const settingsButton = document.getElementById('settingsButton');
        const winMessage = document.getElementById('winMessage'); // Yeni eklenen bölüm tamamlandı mesajı
        const levelIndicator = document.getElementById('levelIndicator'); // Level göstergesi
        const timerDisplay = document.getElementById('timerDisplay'); // Timer göstergesi

        // Zaman değişkenleri
        const levelTimeLimit = 120; // Her bölüm için süre sınırı (saniye)
        let timeRemaining; // Kalan süre
        let timerInterval; // setInterval ID'si

        /**
         * Oyun seviyelerinin tanımlandığı dizi.
         * Her bir seviye, hareketli kutuların, hedef çemberlerin ve **ENGEL KUTULARININ** başlangıç konumlarını içerir.
         * Koordinatlar ekran genişliği ve yüksekliğinin yüzdesi olarak tanımlanmıştır.
         */
        const levels = [
            // Level 1
            {
                boxPositions: [
                    { x: 0.2, y: 0.5 },
                    { x: 0.7, y: 0.1 },
                    { x: 0.8, y: 0.6 },
                    { x: 0.25, y: 0.2 }
                ],
                targetCirclePositions: [
                    { x: 0.7, y: 0.3 },
                    { x: 0.3, y: 0.3 },
                    { x: 0.7, y: 0.7 },
                    { x: 0.3, y: 0.7 }
                ],
                obstaclePositions: [ // Yeni: Engeller
                    { x: 0.5, y: 0.2, width: 0.2, height: 0.1 },
                    { x: 0.5, y: 0.7, width: 0.05, height: 0.2 }
                ]
            },
            // Level 2
            {
                boxPositions: [
                    { x: 0.15, y: 0.5 },
                    { x: 0.85, y: 0.5 },
                    { x: 0.5, y: 0.15 },
                    { x: 0.5, y: 0.85 },
                ],
                targetCirclePositions: [
                    { x: 0.25, y: 0.2 },
                    { x: 0.75, y: 0.25 },
                    { x: 0.25, y: 0.75 },
                    { x: 0.8, y: 0.75 }
                ],
                obstaclePositions: [ // Yeni: Engeller
                    { x: 0.4, y: 0.3, width: 0.1, height: 0.1 },
                    { x: 0.6, y: 0.7, width: 0.1, height: 0.1 },
                    { x: 0.5, y: 0.05, width: 0.3, height: 0.05 }
                ]
            },
            // Level 3
            
            // Daha fazla seviye buraya eklenebilir
        ];

        /**
         * Box (Kutu) sınıfı. Hem oyuncu kutusu hem de hareket ettirilebilir diğer kutular için kullanılır.
         * @param {number} x - Kutunun X koordinatı.
         * @param {number} y - Kutunun Y koordinatı.
         * @param {number} width - Kutunun genişliği.
         * @param {number} height - Kutunun yüksekliği.
         * @param {string} color - Kutunun rengi (örneğin, "#FF0000" veya "blue").
         */
        function Box(x, y, width, height, color) {
            this.x = x; // Kutunun anlık X koordinatı
            this.y = y; // Kutunun anlık Y koordinatı
            this.width = width; // Kutunun genişliği
            this.height = height; // Kutunun yüksekliği
            this.color = color; // Kutunun çizim rengi
            this.dx = 0; // X eksenindeki hızı (delta x)
            this.dy = 0; // Y eksenindeki hızı (delta y)
        }

        /**
         * Kutuyu canvas üzerine çizer.
         */
        Box.prototype.draw = function() {
            ctx.fillStyle = this.color; // Çizim rengini ayarla
            ctx.fillRect(this.x, this.y, this.width, this.height); // Dikdörtgeni çizer
        };

        /**
         * Kutunun pozisyonunu hızına göre günceller ve canvas sınırları içinde kalmasını sağlar.
         * Ayrıca kutulara sürtünme (yavaşlama) uygular.
         */
        Box.prototype.update = function() {
            this.x += this.dx; // X koordinatını hızına göre güncelle
            this.y += this.dy; // Y koordinatını hızına göre güncelle

            // Sürtünme/yavaşlama efekti uygula
            this.dx *= 0.93; // Hızı her karede %7 azalt
            this.dy *= 0.93; // Hızı her karede %7 azalt

            // Canvas sınır kontrolleri: Kutunun canvas dışına çıkmasını engeller ve geri sektirir
            if (this.x < 0) {
                this.x = 0; // X koordinatını sıfıra sabitle
                this.dx *= -2; // Hızı tersine çevir ve enerji kaybı uygula (sekme efekti)
            } else if (this.x + this.width > canvas.width) {
                this.x = canvas.width - this.width; // Kutuyu sağ sınıra sabitle
                this.dx *= -2;
            }
            if (this.y < 0) {
                this.y = 0; // Y koordinatını sıfıra sabitle
                this.dy *= -2;
            } else if (this.y + this.height > canvas.height) {
                this.y = canvas.height - this.height; // Kutuyu alt sınıra sabitle
                this.dy *= -2;
            }

            // Hız çok küçükse (neredeyse durduysa) sıfırla, bu titremeyi önler
            if (Math.abs(this.dx) < 0.1) this.dx = 0;
            if (Math.abs(this.dy) < 0.1) this.dy = 0;
        };

        /**
         * Yeni: Obstacle (Engel) sınıfı. Sabit, hareket etmeyen engeller için kullanılır.
         * Box sınıfı ile aynı yapıya sahip ancak update metodu yoktur.
         * @param {number} x - Engelin X koordinatı.
         * @param {number} y - Engelin Y koordinatı.
         * @param {number} width - Engelin genişliği.
         * @param {number} height - Engelin yüksekliği.
         * @param {string} color - Engelin rengi.
         */
        function Obstacle(x, y, width, height, color) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.color = color;
        }

        /**
         * Engeli canvas üzerine çizer.
         */
        Obstacle.prototype.draw = function() {
            const brickColor = '#A7370A'; // Tuğla rengi
            const mortarColor = '#3a3131'; // Harç rengi (daha koyu)
            const borderWidth = 2; // Harç çizgisi kalınlığı (aynı zamanda tuğla borderı olacak)

            const numRows = 5; // Örneğin, 5 sıra tuğla
            const numCols = 5; // Örneğin, 5 sütun tuğla

            const singleBrickHeight = this.height / numRows;
            const singleBrickWidth = this.width / numCols;

            ctx.strokeStyle = mortarColor; // Harç rengi aynı zamanda tuğla border rengi olacak
            ctx.lineWidth = borderWidth;

            for (let r = 0; r < numRows; r++) {
                for (let c = 0; c < numCols; c++) {
                    const brickX = this.x + c * singleBrickWidth;
                    const brickY = this.y + r * singleBrickHeight;

                    // Her bir tuğla parçasını doldur
                    ctx.fillStyle = brickColor;
                    ctx.fillRect(brickX, brickY, singleBrickWidth, singleBrickHeight);

                    // Her bir tuğla parçasına siyah border çiz
                    // ctx.strokeStyle = 'black'; // Siyah border istiyorsanız bu satırı kullanın
                    // ctx.strokeRect(brickX, brickY, singleBrickWidth, singleBrickHeight);

                    // Alternatif olarak, harç rengini kullanarak border çizebilirsiniz (daha bütünleşik bir görünüm için)
                    ctx.strokeRect(brickX, brickY, singleBrickWidth, singleBrickHeight);
                }
            }
        };

        /**
         * Circle (Çember) sınıfı. Sabit hedef çemberler için kullanılır.
         * @param {number} x - Çemberin merkez X koordinatı.
         * @param {number} y - Çemberin merkez Y koordinatı.
         * @param {number} radius - Çemberin yarıçapı.
         * @param {string} color - Çemberin rengi.
         */
        function Circle(x, y, radius, color) {
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.color = color;
            this.isFilled = false; // Yeni özellik: Kutucuk içine girdiğinde true olacak
        }

        /**
         * Çemberi canvas üzerine çizer.
         */
        Circle.prototype.draw = function() {
            ctx.fillStyle = this.color; // Normal çizgi rengi
            ctx.globalAlpha = 0.35
            
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.arc(parseInt(this.x),parseInt(this.y), parseInt(this.radius), 0, Math.PI * 2);
            ctx.fill();

            ctx.globalAlpha = 1
            // Eğer bu çember doğru kutucukla doldurulmuşsa ek bir kenarlık çiz
            if (this.isFilled) {
                ctx.fillStyle = '#FFF'; // Parlak yeşil kenarlık (isteğe bağlı renk)
                ctx.globalAlpha = 0.1
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius + 2, 0, Math.PI * 2); // Çemberin dışına doğru biraz daha büyük çiz
                ctx.fill();
                ctx.globalAlpha = 1
            }
        };


        /**
         * İki kutu arasında eksen hizalı sınırlayıcı kutu (AABB) çarpışma tespiti yapar.
         * @param {object} box1 - İlk kutu nesnesi (Box veya Obstacle olabilir).
         * @param {object} box2 - İkinci kutu nesnesi (Box veya Obstacle olabilir).
         * @returns {boolean} - Çarpışma varsa true, yoksa false döner.
         */
        function checkCollision(box1, box2) {
            return box1.x < box2.x + box2.width &&
                   box1.x + box1.width > box2.x &&
                   box1.y < box2.y + box2.height &&
                   box1.y + box1.height > box2.y;
        }

        /**
         * Oyuncu kutusu veya hareketli kutu ile sabit bir engel arasındaki çarpışmayı çözer.
         * İtilen kutuyu engel dışına çıkarır ve hızını engelden sekecek şekilde ayarlar.
         * @param {Box} movingBox - Hareket eden kutu (oyuncu veya hareketli kutu).
         * @param {Obstacle} staticObject - Çarpışılan sabit nesne (engel veya canvas kenarı gibi davranır).
         */
        function resolveCollisionWithStatic(movingBox, staticObject) {
            // İki kutunun merkez noktaları arasındaki farkı hesapla
            const dx = (staticObject.x + staticObject.width / 2) - (movingBox.x + movingBox.width / 2);
            const dy = (staticObject.y + staticObject.height / 2) - (movingBox.y + movingBox.height / 2);

            // İki kutunun yarı genişlikleri ve yarı yükseklikleri toplamı
            const combinedHalfWidths = movingBox.width / 2 + staticObject.width / 2;
            const combinedHalfHeights = movingBox.height / 2 + staticObject.height / 2;

            // X ve Y eksenindeki çakışma miktarlarını hesapla
            const overlapX = combinedHalfWidths - Math.abs(dx);
            const overlapY = combinedHalfHeights - Math.abs(dy);

            // Çakışma yoksa veya geçersiz bir durumsa çık
            if (overlapX <= 0 || overlapY <= 0) return;

            const restitution = 0.5; // Geri sekme katsayısı (0: yapışır, 1: tam seker)

            if (overlapX >= overlapY) { // Dikey çakışma daha az ise, yatay bir çarpışma oldu
                if (dy > 0) { // Hareketli kutu engelin üstünde, aşağı doğru itiliyor
                    movingBox.y -= overlapY; // Kutuyu engelden çıkar
                    movingBox.dy *= -restitution; // Dikey hızı tersine çevir ve azalt
                } else { // Hareketli kutu engelin altında, yukarı doğru itiliyor
                    movingBox.y += overlapY;
                    movingBox.dy *= -restitution;
                }
            } else { // Yatay çakışma daha az ise, dikey bir çarpışma oldu
                if (dx > 0) { // Hareketli kutu engelin solunda, sağa doğru itiliyor
                    movingBox.x -= overlapX; // Kutuyu engelden çıkar
                    movingBox.dx *= -restitution; // Yatay hızı tersine çevir ve azalt
                } else { // Hareketli kutu engelin sağında, sola doğru itiliyor
                    movingBox.x += overlapX;
                    movingBox.dx *= -restitution;
                }
            }
            // Hızı sıfıra yakınsa sıfırla
            if (Math.abs(movingBox.dx) < 0.1) movingBox.dx = 0;
            if (Math.abs(movingBox.dy) < 0.1) movingBox.dy = 0;
        }

        /**
         * Oyuncu kutusu ile hareket ettirilebilir kutu arasındaki çarpışma sonrası tepkiyi uygular.
         * Hız ve momentum oranlarını oyuncu hızına göre ayarlar.
         * @param {Box} playerBox - Oyuncu kutusu nesnesi.
         * @param {Box} targetBox - Oyuncu ile çarpışan hedef kutu nesnesi.
         */
        function resolvePlayerCollision(playerBox, targetBox) {
            // İki kutunun merkez noktaları arasındaki farkı hesapla
            const dx = (targetBox.x + targetBox.width / 2) - (playerBox.x + playerBox.width / 2);
            const dy = (targetBox.y + targetBox.height / 2) - (playerBox.y + playerBox.height / 2);

            // İki kutunun yarı genişlikleri ve yarı yükseklikleri toplamı
            const combinedHalfWidths = playerBox.width / 2 + targetBox.width / 2;
            const combinedHalfHeights = playerBox.height / 2 + targetBox.height / 2;

            // X ve Y eksenindeki çakışma miktarlarını hesapla
            const overlapX = combinedHalfWidths - Math.abs(dx);
            const overlapY = combinedHalfHeights - Math.abs(dy);

            // Çakışmanın hangi eksende daha küçük olduğunu kontrol et (çarpışma yönünü belirler)
            if (overlapX >= overlapY) { // Dikey çakışma daha az ise, yatay bir çarpışma oldu (üstten/alttan itme)
                if (dy > 0) { // Oyuncu kutusu hedef kutunun üstünde, aşağı doğru itiyor
                    targetBox.y += overlapY + 1; 
                    targetBox.dy = (playerBox.dy * 0.8); // Oyuncunun dikey hızının %80'ini aktar
                    playerBox.dy *= -0.2; // Oyuncu kutusuna hafif bir geri tepme ver
                } else { // Oyuncu kutusu hedef kutunun altında, yukarı doğru itiyor
                    targetBox.y -= overlapY + 1;
                    targetBox.dy = (playerBox.dy * 0.8); // Oyuncunun dikey hızının %80'ini aktar
                    playerBox.dy *= -0.2;
                }
            } else { // Yatay çakışma daha az ise, dikey bir çarpışma oldu (soldan/sağdan itme)
                if (dx > 0) { // Oyuncu kutusu hedef kutunun solunda, sağa doğru itiyor
                    targetBox.x += overlapX + 1;
                    targetBox.dx = (playerBox.dx * 0.8); // Oyuncunun yatay hızının %80'ini aktar
                    playerBox.dx *= -0.2;
                } else { // Oyuncu kutusu hedef kutunun sağında, sola doğru itiyor
                    targetBox.x -= overlapX + 1;
                    targetBox.dx = (playerBox.dx * 0.8); // Oyuncunun yatay hızının %80'ini aktar
                    playerBox.dx *= -0.2;
                }
            }
        }

        /**
         * İki hareketli kutu arasında çarpışma sonrası fiziksel tepkiyi uygular.
         * Kutuların çakışmasını giderir ve hızlarını ayarlar.
         * @param {Box} box1 - İlk kutu nesnesi.
         * @param {Box} box2 - İkinci kutu nesnesi.
         */
        function resolveBoxToBoxCollision(box1, box2) {
            // Kutuların merkez noktaları arasındaki farkı hesapla
            const dx = (box2.x + box2.width / 2) - (box1.x + box1.width / 2);
            const dy = (box2.y + box2.height / 2) - (box1.y + box1.height / 2);

            // İki kutunun yarı genişlikleri ve yarı yükseklikleri toplamı
            const combinedHalfWidths = box1.width / 2 + box2.width / 2;
            const combinedHalfHeights = box1.height / 2 + box2.height / 2;

            // X ve Y eksenindeki çakışma miktarlarını hesapla
            const overlapX = combinedHalfWidths - Math.abs(dx);
            const overlapY = combinedHalfHeights - Math.abs(dy);

            if (overlapX <= 0 || overlapY <= 0) return; // Çakışma yoksa veya tam sınırlarda ise işlem yapma

            const elasticity = 0.8; // Esneklik katsayısı (0-1 arası, 1 tam esnek)

            if (overlapX >= overlapY) { // Dikey çakışma daha az ise, yatay bir çarpışma oldu
                // Kutuları çakışmadan ayır
                if (dy > 0) { // box1 üstte, box2 altta
                    box1.y -= overlapY / 2;
                    box2.y += overlapY / 2;
                } else { // box1 altta, box2 üstte
                    box1.y += overlapY / 2;
                    box2.y -= overlapY / 2;
                }
                // Hızları tersine çevir ve esneklik uygula
                const tempDY1 = box1.dy;
                box1.dy = box2.dy * elasticity;
                box2.dy = tempDY1 * elasticity;

            } else { // Yatay çakışma daha az ise, dikey bir çarpışma oldu
                // Kutuları çakışmadan ayır
                if (dx > 0) { // box1 solda, box2 sağda
                    box1.x -= overlapX / 2;
                    box2.x += overlapX / 2;
                } else { // box1 sağda, box2 solda
                    box1.x -= overlapX / 2;
                    box2.x -= overlapX / 2;
                }
                // Hızları tersine çevir ve esneklik uygula
                const tempDX1 = box1.dx;
                box1.dx = box2.dx * elasticity;
                box2.dx = tempDX1 * elasticity;
            }
        }

        /**
         * Bir kutucuğun merkezinin bir çemberin içinde olup olmadığını kontrol eder.
         * @param {Box} box - Kontrol edilecek kutu nesnesi.
         * @param {Circle} circle - Hedef çember nesnesi.
         * @returns {boolean} - Kutu çemberin içindeyse true, aksi halde false.
         */
        function isBoxInCircle(box, circle) {
            // Kutucuğun merkez koordinatları
            const boxCenterX = box.x + box.width / 2;
            const boxCenterY = box.y + box.height / 2;

            // Kutucuk merkezi ile çember merkezi arasındaki mesafeyi hesapla
            const distance = Math.sqrt(
                Math.pow(boxCenterX - circle.x, 2) +
                Math.pow(boxCenterY - circle.y, 2)
            );

            // Mesafe, çemberin yarıçapından küçük veya eşitse kutucuk çemberin içindedir.
            // Kutunun tamamının çember içinde olmasını sağlamak için, kutu çapının yarısını da hesaba katıyoruz.
            return distance + box.width / 2 <= circle.radius; 
        }

        /**
         * Oyunun kazanma koşulunu kontrol eder: Tüm hareketli kutucuklar kendi renklerindeki çemberlerin içinde mi?
         * Kazanıldığında bir sonraki seviyeye geçişi tetikler.
         * @returns {boolean} - Kazanma koşulu sağlanırsa true, aksi halde false.
         */
        function checkWinCondition() {
            let allBoxesInCircles = true;

            // Her bir hareketli kutucuk için kontrol et
            for (let i = 0; i < movableBoxes.length; i++) {
                const box = movableBoxes[i];
                const circle = targetCircles[i];

                if (box.color === circle.color && isBoxInCircle(box, circle)) {
                    circle.isFilled = true; // Kutucuk doğru çemberin içindeyse dolduruldu olarak işaretle
                    // Bu kutucuk doğru çemberinde, devam et
                } else {
                    circle.isFilled = false; // Kutucuk dışarıdaysa veya yanlışsa doldurulmadı olarak işaretle
                    allBoxesInCircles = false;
                }
            }

            if (allBoxesInCircles) {
                console.log("Bölümü Geçtiniz!");
                winMessage.style.display = 'block';
                gameRunning = false;
                clearInterval(timerInterval); // Zamanlayıcıyı durdur

                winMessage.onclick = () => {
                    winMessage.style.display = 'none';
                    currentLevel++;
                    saveLevelToLocalStorage();
                    if (currentLevel < levels.length) {
                        initializeGame();
                        requestAnimationFrame(gameLoop);
                    } else {
                        alert("Tüm seviyeleri tamamladınız! Tebrikler!");
                        document.body.classList.remove('game-active'); // Ana menüye dön
                        currentLevel = 0; // Seviyeyi sıfırla
                        saveLevelToLocalStorage();
                        clearInterval(timerInterval); // Oyun bittiğinde zamanlayıcıyı durdur
                        //timerDisplay.style.display = 'none'; // Zaman göstergesini gizle
                        // NEW FIX: When all levels are done and the game returns to the main menu,
                        // the timer needs to be re-initialized when the 'Start' button is clicked.
                        // The 'startButton' event listener already calls initializeGame(),
                        // so we just need to make sure the timer display is set to 'block'
                        // when the game starts, which is handled in initializeGame().
                        // No explicit call needed here after returning to main menu.
                    }
                };
                return true;
            }
            return false;
        }

        /**
         * Mevcut seviyeyi yeniden başlatır (zaman bittiğinde çağrılır).
         */
        function resetLevel() {
            alert("Süreniz bitti! Level yeniden başlıyor.");
            clearInterval(timerInterval); // Mevcut zamanlayıcıyı durdur
            initializeGame(); // Oyunu mevcut seviye ile yeniden başlat
            requestAnimationFrame(gameLoop); // Oyun döngüsünü yeniden başlat
        }

        // Klavye tuş basım durumlarını izlemek için bir obje
        let keys = {};
        // Tuşa basıldığında ilgili tuşu 'true' olarak işaretle
        window.addEventListener('keydown', (e) => {
            // Sadece oyun aktifse klavye girişlerini işle
            if (document.body.classList.contains('game-active') && gameRunning) {
                keys[e.key.toLowerCase()] = true; // Tuş adını küçük harfe çevir
            }
        });
        // Tuş bırakıldığında ilgili tuşu 'false' olarak işaretle
        window.addEventListener('keyup', (e) => {
            if (document.body.classList.contains('game-active') && gameRunning) {
                keys[e.key.toLowerCase()] = false; // Tuş adını küçük harfe çevir
            }
        });

        /**
         * Oyuncu girişlerini (klavye tuşları ve joystick) işler ve oyuncu kutusunun hızını ayarlar.
         * Bu fonksiyon her karede çağrılır.
         */
        function handlePlayerInput() {
            // Eğer joystick basılı tutuluyorsa VE joystick'i sadece yeniden konumlandırmıyorsak
            if (joystickHolding && !repositioningJoystick) {
                // Joystick topunun merkezden uzaklığını hesapla (0 ile joystickRadius arası)
                const distance = Math.sqrt(joystickThumbX * joystickThumbX + joystickThumbY * joystickThumbY);
                
                // Uzaklığa göre hız faktörünü hesapla (0'dan 1'e kadar)
                const speedFactor = distance / joystickRadius;

                // Oyuncunun hızını joystick yönüne ve hız faktörüne göre ayarla
                player.dx = (joystickThumbX / joystickRadius) * PLAYER_SPEED * speedFactor;
                player.dy = (joystickThumbY / joystickRadius) * PLAYER_SPEED * speedFactor;
            } else {
                // Eğer joystick bırakıldıysa veya yeniden konumlandırılıyorsa, 
                // ve klavye girişi varsa, klavye ile hızı ayarla.
                // Aksi takdirde, hızı sıfırla.
                player.dx = 0;
                player.dy = 0;

                // Klavye kontrolü sadece joystick basılı değilse veya yeniden konumlandırılmıyorsa devreye girer.
                // VEYA joystick Holding true ama repositioningJoystick false ise.
                // Bu durumda, sadece klavye ile hareket edebilir.
                if (!joystickHolding || (joystickHolding && repositioningJoystick === false)) {
                     if (keys['arrowup'] || keys['w']) player.dy = -PLAYER_SPEED;
                     if (keys['arrowdown'] || keys['s']) player.dy = PLAYER_SPEED;
                     if (keys['arrowleft'] || keys['a']) player.dx = -PLAYER_SPEED;
                     if (keys['arrowright'] || keys['d']) player.dx = PLAYER_SPEED;
                }
               
            }
        }

        /**
         * Ana oyun döngüsü. Her karede oyunun durumunu günceller ve yeniden çizer.
         */
        function gameLoop() {
            // Eğer oyun aktif değilse veya kazanıldıysa veya süre bittiyse döngüyü durdur
            if (!document.body.classList.contains('game-active') || !gameRunning || timeRemaining <= 0) {
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height); // Canvas'ın tamamını temizle

            // Çemberleri çiz (Kutulardan önce çizilmeli ki kutular üzerlerinde görünsün)
            targetCircles.forEach(circle => {
                circle.draw();
            });

            // Engelleri çiz (Kutulardan önce çizilmeli ki kutular üzerlerinde görünsün)
            obstacles.forEach(obstacle => {
                obstacle.draw();
            });

            handlePlayerInput(); // Oyuncu girişini işle (klavye ve joystick) - burada dx/dy atanıyor
            player.update(); // Oyuncu kutusunun pozisyonunu güncelle
            player.draw(); // Oyuncu kutusunu çiz

            // Hareket ettirilebilir her kutu için döngü
            movableBoxes.forEach(box => {
                box.update(); // Kutunun pozisyonunu güncelle
                box.draw(); // Kutuyu çiz

                // Oyuncu kutusu ile mevcut hareket ettirilebilir kutu arasında çarpışma kontrolü yap
                if (checkCollision(player, box)) {
                    resolvePlayerCollision(player, box); // Çarpışmayı çöz (itme mekanizması)
                }

                // Hareketli kutuların engellerle çarpışmasını kontrol et
                obstacles.forEach(obstacle => {
                    if (checkCollision(box, obstacle)) {
                        resolveCollisionWithStatic(box, obstacle); // Engel çarpışmasını çöz
                    }
                });
            });

            // Oyuncunun engellerle çarpışmasını kontrol et
            obstacles.forEach(obstacle => {
                if (checkCollision(player, obstacle)) {
                    resolveCollisionWithStatic(player, obstacle); // Engel çarpışmasını çöz
                }
            });

            // Hareket ettirilebilir kutular arası çarpışmaları kontrol et ve çöz
            for (let i = 0; i < movableBoxes.length; i++) {
                for (let j = i + 1; j < movableBoxes.length; j++) { // j = i + 1 ile aynı kutuyu kontrol etmeyi ve tekrarlanan kontrolleri önle
                    const box1 = movableBoxes[i];
                    const box2 = movableBoxes[j];

                    if (checkCollision(box1, box2)) {
                        resolveBoxToBoxCollision(box1, box2); // Kutuların kendi aralarındaki çarpışmayı çöz
                    }
                }
            }

            // Kazanma koşulunu kontrol et
            if (!checkWinCondition()) { // Eğer kazanma koşulu sağlanmadıysa, oyun döngüsünü devam ettir
                requestAnimationFrame(gameLoop); 
            } else {
                // Kazanma koşulu sağlandıysa gameLoop'u tekrar çağırma, oyun durur.
            }
        }

        /**
         * Joystick'i başlatır ve olay dinleyicilerini ayarlar.
         * Bu fonksiyon, joystick'in boyutlarını ve varsayılan konumunu ayarlar.
         */
        function setupJoystick() {
            joystickContainer = document.getElementById('joystick-container');
            joystickThumb = document.getElementById('joystick-thumb');

            // Joystick boyutlarını ekranın kısa kenarına göre ayarla
            const minDim = Math.min(window.innerWidth, window.innerHeight);
            joystickRadius = minDim * 0.15; // Önceki değerin 1.5 katı oldu (0.1 -> 0.15)
            thumbRadius = joystickRadius * 0.4; // Joystick topu, joystick'in %40'ı kadar olsun

            joystickContainer.style.width = `${joystickRadius * 2}px`;
            joystickContainer.style.height = `${joystickRadius * 2}px`;
            joystickThumb.style.width = `${thumbRadius * 2}px`;
            joystickThumb.style.height = `${thumbRadius * 2}px`;

            // Varsayılan boşluk değeri (2rem)
            const remValue = parseFloat(getComputedStyle(document.documentElement).fontSize);
            const padding = 2 * remValue; // 2rem boşluk

            // Joystick'i varsayılan sağ alt konuma ayarla
            joystickContainer.style.right = `${padding}px`;   // Sağ kenardan boşluk
            joystickContainer.style.bottom = `${padding}px`;  // Alt kenardan boşluk
            joystickContainer.style.left = 'auto';            // Sol konumunu sıfırla
            joystickContainer.style.top = 'auto';              // Üst konumunu sıfırla

            // Joystick'in tam merkezini hesapla (varsayılan konumuna göre)
            updateJoystickCenter();
        }

        /**
         * Joystick'in anlık merkez koordinatlarını günceller.
         * Bu fonksiyon, joystick'in konumu değiştiğinde çağrılmalıdır.
         */
        function updateJoystickCenter() {
            const rect = joystickContainer.getBoundingClientRect();
            joystickCenterX = rect.left + joystickRadius;
            joystickCenterY = rect.top + joystickRadius;
        }

        /**
         * Joystick topunu dokunma/mouse pozisyonuna göre hareket ettirir
         * ve joystickThumbX/Y değerlerini günceller.
         * @param {number} clientX - Dokunma/mouse'un X koordinatı.
         * @param {number} clientY - Dokunma/mouse'un Y koordinatı.
         */
        function updateJoystickThumbPosition(clientX, clientY) {
            // Joystick'in merkezinden olan ofseti (uzaklığı) hesapla
            let offsetX = clientX - joystickCenterX;
            let offsetY = clientY - joystickCenterY;

            // Topu joystick'in yarıçapı içinde tut
            const distance = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
            if (distance > joystickRadius) {
                const angle = Math.atan2(offsetY, offsetX);
                offsetX = joystickRadius * Math.cos(angle);
                offsetY = joystickRadius * Math.sin(angle);
            }

            // joystickThumbX ve joystickThumbY global değişkenlerini güncelle
            joystickThumbX = offsetX;
            joystickThumbY = offsetY;

            // Joystick topunun pozisyonunu CSS transform ile güncelle
            joystickThumb.style.transform = `translate(calc(-50% + ${offsetX}px), calc(-50% + ${offsetY}px))`;
        }

        /**
         * Mevcut seviyeyi tarayıcının yerel depolama alanına kaydeder.
         */
        function saveLevelToLocalStorage() {
            localStorage.setItem('currentLevel', currentLevel);
        }

        /**
         * Tarayıcının yerel depolama alanından kayıtlı seviyeyi yükler.
         * Kayıtlı bir seviye yoksa 0 (ilk seviye) döner.
         * @returns {number} - Kayıtlı seviye numarası.
         */
        function loadLevelFromLocalStorage() {
            const savedLevel = localStorage.getItem('currentLevel');
            return savedLevel ? parseInt(savedLevel, 10) : 0;
        }


        /**
         * Oyunun başlangıçta yüklenmesi ve başlatılması.
         * Tüm kutuları ve çemberleri oluşturur ve olay dinleyicilerini ayarlar.
         */
        function initializeGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            // Canvas boyutunu tam ekran olarak ayarla
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Kutucuk boyutlarını ve hızı ekran boyutlarına göre orantılı ayarla
            const minDim = Math.min(canvas.width, canvas.height);
            playerSize = minDim * 0.08; 
            boxSize = minDim * 0.06;    
            obstacleSize = minDim * 0.1; 
            circleRadius = boxSize * 1.5; 
            PLAYER_SPEED = minDim * 0.005; 

            // Oyuncu kutusunu oluştur (her seviyede ortaya sıfırla)
            player = new Box(canvas.width / 2 - playerSize / 2, canvas.height / 2 - playerSize / 2, playerSize, playerSize, '#2c2cdd'); 

            // Mevcut seviyenin konum verilerini al
            const currentLevelData = levels[currentLevel];
            const boxPositions = currentLevelData.boxPositions;
            const targetCirclePositions = currentLevelData.targetCirclePositions;
            const obstaclePositions = currentLevelData.obstaclePositions || []; 

            // Hareket ettirilebilir kutuları, hedef çemberleri ve engelleri temizle ve yeniden oluştur
            movableBoxes = []; 
            targetCircles = [];
            obstacles = []; 

            // Her bir sabit konum için kutu ve çember oluştur
            for (let i = 0; i < NUM_MOVABLE_BOXES; i++) {
                const itemColor = `hsl(${i * 90}, 60%, 50%)`; 

                const boxPos = boxPositions[i];
                movableBoxes.push(new Box(canvas.width * boxPos.x - boxSize / 2, canvas.height * boxPos.y - boxSize / 2, boxSize, boxSize, itemColor));

                const circlePos = targetCirclePositions[i];
                targetCircles.push(new Circle(canvas.width * circlePos.x, canvas.height * circlePos.y, circleRadius, itemColor)); 
            }

            // Engelleri oluştur
            obstaclePositions.forEach(obsPos => {
                const obsWidth = canvas.width * obsPos.width;
                const obsHeight = canvas.height * obsPos.height;
                obstacles.push(new Obstacle(canvas.width * obsPos.x - obsWidth / 2, canvas.height * obsPos.y - obsHeight / 2, obsWidth, obsHeight, '#B45F06'));
            });
            
            // Oyun başladığında joystick'i kur ve konumlandır
            setupJoystick();

            // Joystick topunu merkeze sıfırla ve ilgili değişkenleri sıfırla
            joystickThumb.style.transform = `translate(-50%, -50%)`;
            joystickThumbX = 0;
            joystickThumbY = 0;

            // Oyun başlangıcında mesajı gizle
            winMessage.style.display = 'none'; 
            gameRunning = true; 
            levelIndicator.textContent = `Level: ${currentLevel + 1}`;

            // Zamanlayıcıyı başlat
            timeRemaining = levelTimeLimit;
            timerDisplay.textContent = `Time: ${timeRemaining}`;
            clearInterval(timerInterval); // Önceki zamanlayıcıyı temizle
            timerInterval = setInterval(() => {
                timeRemaining--;
                timerDisplay.textContent = `Time: ${timeRemaining}`;
                if (timeRemaining <= 0) {
                    clearInterval(timerInterval);
                    resetLevel();
                }
            }, 1000);

            // Joystick topunu merkeze sıfırla ve ilgili değişkenleri sıfırla
            joystickThumb.style.transform = `translate(-50%, -50%)`;
            joystickThumbX = 0;
            joystickThumbY = 0;
            joystickHolding = false;       // Joystick tutma durumunu sıfırla
            repositioningJoystick = false; // Joystick yeniden konumlandırma durumunu sıfırla

            // Klavye tuş basım durumlarını sıfırla
            keys = {};
        }

        // Pencere boyutu değiştiğinde oyun ayarlarını güncelle
        window.addEventListener('resize', () => {
            if (document.body.classList.contains('game-active')) {
                // Sadece mevcut seviyenin tekrar yüklenmesi yeterli, level sıfırlanmamalı
                initializeGame(); 
            }
        });

        // Ana Menü Butonları İşlevselliği
        startButton.addEventListener('click', () => {
            document.body.classList.add('game-active'); // Body'ye "game-active" sınıfını ekle
            currentLevel = loadLevelFromLocalStorage(); // Kayıtlı seviyeyi yükle
            initializeGame(); // Oyunu başlat veya sıfırla
            requestAnimationFrame(gameLoop); // Oyun döngüsünü başlat
        });

        historyButton.addEventListener('click', () => {
            alert('Geçmiş burada gösterilecek!'); // Geçmiş ekranı için placeholder
        });

        settingsButton.addEventListener('click', () => {
            alert('Ayarlar burada gösterilecek!'); // Ayarlar ekranı için placeholder
        });

        // Dokunma başlangıcı olayı (Mobil Cihazlar İçin)
        window.addEventListener('touchstart', (e) => {
            if (!document.body.classList.contains('game-active') || !gameRunning) return; 

            const touch = e.touches[0];
            const isInsideJoystick = joystickContainer.contains(document.elementFromPoint(touch.clientX, touch.clientY));

            if (isInsideJoystick) {
                // Joystick'in içine dokunulduysa normal joystick kullanımı
                joystickHolding = true; 
                repositioningJoystick = false; // Oyuncu hareketi başlasın
                updateJoystickCenter(); 
                updateJoystickThumbPosition(touch.clientX, touch.clientY); 
            } else {
                // Joystick dışına dokunulduysa, sadece joystick'i yeniden konumlandır
                joystickHolding = true; 
                repositioningJoystick = true; // Oyuncu hareketi olmasın
                
                const newX = touch.clientX - joystickRadius;
                const newY = touch.clientY - joystickRadius;

                // Joystick'i ekran sınırları içinde tut
                const clampedX = Math.max(0, Math.min(window.innerWidth - joystickRadius * 2, newX));
                const clampedY = Math.max(0, Math.min(window.innerHeight - joystickRadius * 2, newY));

                joystickContainer.style.left = `${clampedX}px`;
                joystickContainer.style.top = `${clampedY}px`;
                joystickContainer.style.right = 'auto';            // Sağ konumunu sıfırla
                joystickContainer.style.bottom = 'auto';            // Alt konumunu sıfırla
                
                updateJoystickCenter(); 
                // Yeniden konumlandırmada topu merkeze sıfırla, hareket başlamaz.
                joystickThumb.style.transform = `translate(-50%, -50%)`; 
                joystickThumbX = 0; 
                joystickThumbY = 0; 
            }
            e.preventDefault(); 
        }, { passive: false });

        // Dokunma hareketi olayı (Mobil Cihazlar İçin)
        window.addEventListener('touchmove', (e) => {
            if (joystickHolding && document.body.classList.contains('game-active') && gameRunning) {
                const touch = e.touches[0]; // İlk dokunuşu al
                if (!repositioningJoystick) { // Eğer joystick'i yeniden konumlandırmıyorsak
                    updateJoystickThumbPosition(touch.clientX, touch.clientY); // Topu sürekli güncelle ve offset'leri ayarla
                } else {
                     // Joystick'i yeniden konumlandırırken, parmağın hareketine göre joystick container'ı taşı
                    const newX = touch.clientX - joystickRadius;
                    const newY = touch.clientY - joystickRadius;

                    const clampedX = Math.max(0, Math.min(window.innerWidth - joystickRadius * 2, newX));
                    const clampedY = Math.max(0, Math.min(window.innerHeight - joystickRadius * 2, newY));

                    joystickContainer.style.left = `${clampedX}px`;
                    joystickContainer.style.top = `${clampedY}px`;
                    joystickContainer.style.right = 'auto';
                    joystickContainer.style.bottom = 'auto';
                    updateJoystickCenter(); // Joystick merkezi güncellenmeli
                }
            }
            e.preventDefault(); 
        }, { passive: false });

        // Dokunma bitişi olayı (Mobil Cihazlar İçin)
        window.addEventListener('touchend', () => {
            if (document.body.classList.contains('game-active') && gameRunning) {
                joystickHolding = false; // Kullanıcı joystick'i bıraktı
                repositioningJoystick = false; // Yeniden konumlandırma bitti
                joystickThumb.style.transform = `translate(-50%, -50%)`; // Topu merkeze döndür
                joystickThumbX = 0; // Offset'leri sıfırla
                joystickThumbY = 0; // Offset'leri sıfırla
            }
        }, { passive: false });

        // Mouse ile tıklama başlangıcı olayı (Masaüstü İçin)
        window.addEventListener('mousedown', (e) => {
            if (!document.body.classList.contains('game-active') || !gameRunning) return; 

            const targetElement = e.target;
            const isInsideJoystick = joystickContainer.contains(targetElement);

            if (isInsideJoystick) {
                // Joystick'in içine tıklandıysa normal joystick kullanımı
                joystickHolding = true; 
                repositioningJoystick = false; // Oyuncu hareketi başlasın
                updateJoystickCenter(); 
                updateJoystickThumbPosition(e.clientX, e.clientY); 
            } else {
                // Joystick dışına tıklandıysa, sadece joystick'i yeniden konumlandır
                joystickHolding = true; 
                repositioningJoystick = true; // Oyuncu hareketi olmasın
                
                const newX = e.clientX - joystickRadius;
                const newY = e.clientY - joystickRadius;

                const clampedX = Math.max(0, Math.min(window.innerWidth - joystickRadius * 2, newX));
                const clampedY = Math.max(0, Math.min(window.innerHeight - joystickRadius * 2, newY));

                joystickContainer.style.left = `${clampedX}px`;
                joystickContainer.style.top = `${clampedY}px`;
                joystickContainer.style.right = 'auto';
                joystickContainer.style.bottom = 'auto';

                updateJoystickCenter(); 
                // Yeniden konumlandırmada topu merkeze sıfırla, hareket başlamaz.
                joystickThumb.style.transform = `translate(-50%, -50%)`; 
                joystickThumbX = 0; 
                joystickThumbY = 0; 
            }
            e.preventDefault(); 
        });

        // Mouse ile hareket olayı (Masaüstü İçin)
        window.addEventListener('mousemove', (e) => {
            if (joystickHolding && document.body.classList.contains('game-active') && gameRunning) {
                if (!repositioningJoystick) { // Eğer joystick'i yeniden konumlandırmıyorsak
                    updateJoystickThumbPosition(e.clientX, e.clientY); // Topu sürekli güncelle ve offset'leri ayarla
                } else {
                    // Joystick'i yeniden konumlandırırken, farenin hareketine göre joystick container'ı taşı
                    const newX = e.clientX - joystickRadius;
                    const newY = e.clientY - joystickRadius;

                    const clampedX = Math.max(0, Math.min(window.innerWidth - joystickRadius * 2, newX));
                    const clampedY = Math.max(0, Math.min(window.innerHeight - joystickRadius * 2, newY));

                    joystickContainer.style.left = `${clampedX}px`;
                    joystickContainer.style.top = `${clampedY}px`;
                    joystickContainer.style.right = 'auto';
                    joystickContainer.style.bottom = 'auto';
                    updateJoystickCenter(); // Joystick merkezi güncellenmeli
                }
            }
        });

        // Mouse ile tıklama bitişi olayı (Masaüstü İçin)
        window.addEventListener('mouseup', () => {
            if (document.body.classList.contains('game-active') && gameRunning) {
                joystickHolding = false; // Kullanıcı joystick'i bıraktı
                repositioningJoystick = false; // Yeniden konumlandırma bitti
                joystickThumb.style.transform = `translate(-50%, -50%)`; // Topu merkeze döndür
                joystickThumbX = 0; // Offset'leri sıfırla
                joystickThumbY = 0; // Offset'leri sıfırla
            }
        });

    </script>
</body>
</html>
